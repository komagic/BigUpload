import React, { useState, useRef, useCallback } from "react";
import {
  Row,
  Col,
  Card,
  Upload,
  Button,
  Progress,
  Space,
  Typography,
  Divider,
  message,
  List,
  Tag,
  Statistic,
  Alert,
  Switch,
  Input,
  Tooltip,
  Badge,
  Select,
} from "antd";
import {
  UploadOutlined,
  InboxOutlined,
  RocketOutlined,
  CheckCircleOutlined,
  ExclamationCircleOutlined,
  CloudServerOutlined,
  ThunderboltOutlined,
  LoadingOutlined,
  DeleteOutlined,
  PlayCircleOutlined,
  PauseCircleOutlined,
  ReloadOutlined,
} from "@ant-design/icons";
import {
  createUploadEngine,
  formatFileSize,
  type UploadProgress,
  type UploadResult,
  type UploadError,
} from "bigupload-frontend";

const { Title, Text, Paragraph } = Typography;
const { Dragger } = Upload;

interface ServerConfig {
  name: string;
  url: string;
  port: number;
  icon: React.ReactNode;
  color: string;
  description: string;
}

interface UploadRecord {
  id: string;
  fileName: string;
  fileSize: number;
  serverName: string;
  status: "pending" | "uploading" | "success" | "error";
  progress: number;
  speed: number;
  elapsedTime: number;
  error?: string;
  result?: any;
  startTime: number;
}

const servers: ServerConfig[] = [
  {
    name: "Node.js",
    url: "http://localhost:3000",
    port: 3000,
    icon: <CloudServerOutlined />,
    color: "#52c41a",
    description: "Express + TypeScript + Multer",
  },
  {
    name: "Python",
    url: "http://localhost:5000",
    port: 5000,
    icon: <ThunderboltOutlined />,
    color: "#1890ff",
    description: "FastAPI + uvloop + aiofiles",
  },
  {
    name: "Java",
    url: "http://localhost:8080",
    port: 8080,
    icon: <RocketOutlined />,
    color: "#fa8c16",
    description: "Spring Boot + Maven",
  },
];

export const MultiServerUploadTest: React.FC = () => {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [uploadRecords, setUploadRecords] = useState<UploadRecord[]>([]);
  const [activeUploads, setActiveUploads] = useState<Set<string>>(new Set());
  const [serverStatus, setServerStatus] = useState<{
    [key: string]: "online" | "offline" | "checking";
  }>({});
  const [activeServer, setActiveServer] = useState<string | null>(null);
  const [chunkSize, setChunkSize] = useState(0.8); // ÈªòËÆ§ 0.8MB - Uppy ÊúÄ‰Ω≥ÂÆûË∑µ

  const uploadEnginesRef = useRef<{ [key: string]: any }>({});

  // Ê£ÄÊµãÁ°¨‰ª∂Âπ∂ÂèëËÉΩÂäõÂπ∂ÊòæÁ§∫‰ø°ÊÅØ
  const hardwareInfo = React.useMemo(() => {
    const hwConcurrency = navigator.hardwareConcurrency || 4;
    const optimalConcurrency =
      hwConcurrency <= 2
        ? 1
        : hwConcurrency <= 4
        ? 2
        : hwConcurrency <= 8
        ? 3
        : Math.min(4, Math.floor(hwConcurrency / 2));

    return {
      cores: hwConcurrency,
      optimalConcurrency,
      chunkSize: chunkSize,
    };
  }, [chunkSize]);

  // ÂàùÂßãÂåñ‰∏ä‰º†ÂºïÊìé - Âü∫‰∫é Uppy ÊúÄ‰Ω≥ÂÆûË∑µ
  React.useEffect(() => {
    servers.forEach((server) => {
      const apiConfig = getServerApiConfig(server);
      uploadEnginesRef.current[server.name] = createUploadEngine(server.url, {
        debug: true,
        chunkSize: chunkSize * 1024 * 1024, // 0.8MB ÈªòËÆ§ÂàÜÁâáÂ§ßÂ∞è
        useHardwareConcurrency: true, // ÂêØÁî®Á°¨‰ª∂ÊÑüÁü•Âπ∂Âèë
        retryDelays: [0, 1000, 3000, 5000, 10000], // TUS È£éÊ†ºÈáçËØïÂª∂Ëøü
        apiPaths: apiConfig,
      });
    });

    return () => {
      // Ê∏ÖÁêÜËµÑÊ∫ê
      Object.values(uploadEnginesRef.current).forEach((engine: any) => {
        if (engine && engine.destroy) {
          engine.destroy();
        }
      });
    };
  }, [chunkSize]);

  // Ëé∑ÂèñÊúçÂä°Âô®APIÈÖçÁΩÆ - ‰∏∫ÊØè‰∏™ÂêéÁ´ØÈÖçÁΩÆÊ≠£Á°ÆÁöÑAPIË∑ØÂæÑ
  const getServerApiConfig = (server: ServerConfig) => {
    if (server.name === "Node.js") {
      // Node.js ‰ΩøÁî®Áõ¥Êé•Ë∑ØÂæÑ
      return {
        verify: "/verify",
        upload: "/upload-chunk",
        merge: "/merge-chunks",
      };
    } else if (server.name === "Python") {
      // Python ‰ΩøÁî® /api/upload ÂâçÁºÄÔºå‰∏î API ÂêçÁß∞‰∏çÂêå
      return {
        verify: "/api/upload/verify",
        upload: "/api/upload/upload", // Ê≥®ÊÑèÔºöPython ÊòØ "upload" ‰∏çÊòØ "upload-chunk"
        merge: "/api/upload/merge", // Ê≥®ÊÑèÔºöPython ÊòØ "merge" ‰∏çÊòØ "merge-chunks"
      };
    } else if (server.name === "Java") {
      // Java ‰ΩøÁî® /api/upload ÂâçÁºÄ
      return {
        verify: "/api/upload/verify",
        upload: "/api/upload/upload-chunk",
        merge: "/api/upload/merge-chunks",
      };
    } else {
      // ÈªòËÆ§ÈÖçÁΩÆÔºàNode.js È£éÊ†ºÔºâ
      return {
        verify: "/verify",
        upload: "/upload-chunk",
        merge: "/merge-chunks",
      };
    }
  };

  // Ê£ÄÊü•ÊúçÂä°Âô®Áä∂ÊÄÅ
  const checkServerStatus = useCallback(async (server: ServerConfig) => {
    setServerStatus((prev) => ({ ...prev, [server.name]: "checking" }));

    try {
      // Ê†πÊçÆ‰∏çÂêåÂêéÁ´Ø‰ΩøÁî®‰∏çÂêåÁöÑÂÅ•Â∫∑Ê£ÄÊü•Ë∑ØÂæÑ
      let healthUrl: string;
      if (server.name === "Node.js") {
        healthUrl = `${server.url}/health`;
      } else if (server.name === "Python") {
        healthUrl = `${server.url}/api/upload/health`;
      } else if (server.name === "Java") {
        healthUrl = `${server.url}/api/upload/health`;
      } else {
        healthUrl = `${server.url}/health`; // ÈªòËÆ§
      }

      // ‰ΩøÁî® AbortController ÂÆûÁé∞Ë∂ÖÊó∂
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);

      const response = await fetch(healthUrl, {
        method: "GET",
        headers: { "Content-Type": "application/json" },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (response.ok) {
        setServerStatus((prev) => ({ ...prev, [server.name]: "online" }));
      } else {
        setServerStatus((prev) => ({ ...prev, [server.name]: "offline" }));
      }
    } catch (error) {
      setServerStatus((prev) => ({ ...prev, [server.name]: "offline" }));
    }
  }, []);

  // Ê£ÄÊü•ÊâÄÊúâÊúçÂä°Âô®Áä∂ÊÄÅ
  const checkAllServers = useCallback(() => {
    servers.forEach(checkServerStatus);
  }, [checkServerStatus]);

  // ÂàùÂßãÊ£ÄÊü•ÊúçÂä°Âô®Áä∂ÊÄÅ
  React.useEffect(() => {
    checkAllServers();
  }, [checkAllServers]);

  // Â§ÑÁêÜÊñá‰ª∂ÈÄâÊã©
  const handleFileSelect = useCallback(
    (file: File) => {
      setSelectedFile(file);
      const sizeInfo = `${(file.size / 1024 / 1024).toFixed(2)}MB`;
      const chunksInfo = Math.ceil(file.size / (chunkSize * 1024 * 1024));
      message.success(
        `üìÅ Â∑≤ÈÄâÊã©: ${file.name} (${sizeInfo}, ${chunksInfo} ÂàÜÁâá)`
      );
      return false; // ÈòªÊ≠¢Ëá™Âä®‰∏ä‰º†
    },
    [chunkSize]
  );

  // ‰∏ä‰º†Âà∞Âçï‰∏™ÊúçÂä°Âô® - Â¢ûÂº∫ÁöÑÈîôËØØÂ§ÑÁêÜÂíåËøõÂ∫¶ËøΩË∏™
  const uploadToServer = async (server: ServerConfig, file: File) => {
    const recordId = `${server.name}-${Date.now()}`;
    const uploadEngine = uploadEnginesRef.current[server.name];

    if (!uploadEngine) {
      message.error(`${server.name} ‰∏ä‰º†ÂºïÊìéÊú™ÂàùÂßãÂåñ`);
      return;
    }

    // ÂàõÂª∫‰∏ä‰º†ËÆ∞ÂΩï
    const record: UploadRecord = {
      id: recordId,
      fileName: file.name,
      fileSize: file.size,
      serverName: server.name,
      status: "pending",
      progress: 0,
      speed: 0,
      elapsedTime: 0,
      startTime: Date.now(),
    };

    setUploadRecords((prev) => [record, ...prev]);
    setActiveUploads((prev) => new Set(prev).add(recordId));

    try {
      // Ê∑ªÂä†Êñá‰ª∂Âà∞‰∏ä‰º†ÂºïÊìé
      const fileId = await uploadEngine.addFile(file);

      // Êõ¥Êñ∞Áä∂ÊÄÅ‰∏∫‰∏ä‰º†‰∏≠
      setUploadRecords((prev) =>
        prev.map((r) =>
          r.id === recordId ? { ...r, status: "uploading" as const } : r
        )
      );

      // ÁõëÂê¨ËøõÂ∫¶ - Êõ¥ËØ¶ÁªÜÁöÑËøõÂ∫¶‰ø°ÊÅØ
      const unsubscribeProgress = uploadEngine.on(
        "progress",
        ({
          fileId: uploadFileId,
          progress,
        }: {
          fileId: string;
          progress: UploadProgress;
        }) => {
          if (uploadFileId === fileId) {
            const elapsed = Date.now() - record.startTime;

            setUploadRecords((prev) =>
              prev.map((r) =>
                r.id === recordId
                  ? {
                      ...r,
                      progress: progress.percent,
                      speed: progress.speed,
                      elapsedTime: elapsed,
                    }
                  : r
              )
            );
          }
        }
      );

      // ÁõëÂê¨ÂàÜÁâáÂÆåÊàê - Êñ∞Â¢ûÁöÑÁªÜÁ≤íÂ∫¶‰∫ã‰ª∂
      const unsubscribeChunkCompleted = uploadEngine.on(
        "chunkCompleted",
        ({ fileId: uploadFileId, chunkIndex, totalChunks }: any) => {
          if (uploadFileId === fileId) {
            console.log(
              `‚úÖ ${server.name}: ÂàÜÁâá ${chunkIndex + 1}/${totalChunks} ÂÆåÊàê`
            );
          }
        }
      );

      // ÁõëÂê¨ÊàêÂäü
      const unsubscribeSuccess = uploadEngine.on(
        "success",
        ({
          fileId: uploadFileId,
          result,
        }: {
          fileId: string;
          result: UploadResult;
        }) => {
          if (uploadFileId === fileId) {
            const elapsed = Date.now() - record.startTime;

            setUploadRecords((prev) =>
              prev.map((r) =>
                r.id === recordId
                  ? {
                      ...r,
                      status: "success" as const,
                      progress: 100,
                      speed: result.averageSpeed || 0,
                      elapsedTime: elapsed,
                      result,
                    }
                  : r
              )
            );

            setActiveUploads((prev) => {
              const newSet = new Set(prev);
              newSet.delete(recordId);
              return newSet;
            });

            const speedInfo = result.averageSpeed
              ? ` (Âπ≥ÂùáÈÄüÂ∫¶: ${(result.averageSpeed / 1024 / 1024).toFixed(
                  2
                )}MB/s)`
              : "";
            message.success(`üéâ ${server.name} ‰∏ä‰º†ÊàêÂäüÔºÅ${speedInfo}`);

            // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨
            unsubscribeProgress();
            unsubscribeSuccess();
            unsubscribeError();
            unsubscribeChunkCompleted();
          }
        }
      );

      // ÁõëÂê¨ÈîôËØØ - Â¢ûÂº∫ÁöÑÈîôËØØ‰ø°ÊÅØ
      const unsubscribeError = uploadEngine.on(
        "error",
        ({
          fileId: uploadFileId,
          error,
        }: {
          fileId: string;
          error: UploadError;
        }) => {
          if (uploadFileId === fileId) {
            setUploadRecords((prev) =>
              prev.map((r) =>
                r.id === recordId
                  ? {
                      ...r,
                      status: "error" as const,
                      error: error.message,
                    }
                  : r
              )
            );

            setActiveUploads((prev) => {
              const newSet = new Set(prev);
              newSet.delete(recordId);
              return newSet;
            });

            const retryInfo = error.retryable ? " (ÂèØÈáçËØï)" : " (‰∏çÂèØÈáçËØï)";
            message.error(
              `‚ùå ${server.name} ‰∏ä‰º†Â§±Ë¥•: ${error.message}${retryInfo}`
            );

            // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨
            unsubscribeProgress();
            unsubscribeSuccess();
            unsubscribeError();
            unsubscribeChunkCompleted();
          }
        }
      );

      // ÂºÄÂßã‰∏ä‰º†
      await uploadEngine.startUpload(fileId);
    } catch (error: any) {
      setUploadRecords((prev) =>
        prev.map((r) =>
          r.id === recordId
            ? {
                ...r,
                status: "error" as const,
                error: error.message,
              }
            : r
        )
      );

      setActiveUploads((prev) => {
        const newSet = new Set(prev);
        newSet.delete(recordId);
        return newSet;
      });

      message.error(`üí• ${server.name} ‰∏ä‰º†ÂºÇÂ∏∏: ${error.message}`);
    }
  };

  // ‰∏ä‰º†Âà∞ÊåáÂÆöÊúçÂä°Âô®
  const handleUploadToServer = async (server: ServerConfig) => {
    if (!selectedFile) {
      message.warning("ËØ∑ÂÖàÈÄâÊã©Êñá‰ª∂");
      return;
    }

    if (serverStatus[server.name] !== "online") {
      message.warning(`${server.name} ÊúçÂä°Âô®Á¶ªÁ∫ø`);
      return;
    }

    if (activeUploads.size > 0) {
      message.warning("ËØ∑Á≠âÂæÖÂΩìÂâç‰∏ä‰º†ÂÆåÊàêÂêéÂÜçËØï");
      return;
    }

    setActiveServer(server.name);
    try {
      await uploadToServer(server, selectedFile);
    } finally {
      setActiveServer(null);
    }
  };

  // È°∫Â∫è‰∏ä‰º†Âà∞ÊâÄÊúâÂú®Á∫øÊúçÂä°Âô®
  const handleUploadToAll = async () => {
    if (!selectedFile) {
      message.warning("ËØ∑ÂÖàÈÄâÊã©Êñá‰ª∂");
      return;
    }

    if (activeUploads.size > 0) {
      message.warning("ËØ∑Á≠âÂæÖÂΩìÂâç‰∏ä‰º†ÂÆåÊàêÂêéÂÜçËØï");
      return;
    }

    const onlineServers = servers.filter(
      (server) => serverStatus[server.name] === "online"
    );

    if (onlineServers.length === 0) {
      message.warning("Ê≤°ÊúâÂú®Á∫øÁöÑÊúçÂä°Âô®");
      return;
    }

    // È°∫Â∫è‰∏ä‰º†Âà∞ÊØè‰∏™Âú®Á∫øÊúçÂä°Âô®
    for (const server of onlineServers) {
      setActiveServer(server.name);
      try {
        await uploadToServer(server, selectedFile);
        // Á≠âÂæÖ‰∏ÄÁßíÂÜç‰∏ä‰º†‰∏ã‰∏Ä‰∏™
        await new Promise((resolve) => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`‰∏ä‰º†Âà∞ ${server.name} Â§±Ë¥•:`, error);
        // ÁªßÁª≠‰∏ä‰º†Âà∞‰∏ã‰∏Ä‰∏™ÊúçÂä°Âô®
      } finally {
        setActiveServer(null);
      }
    }
  };

  // Ê∏ÖÁ©∫ËÆ∞ÂΩï
  const clearRecords = () => {
    setUploadRecords([]);
    setActiveUploads(new Set());
  };

  // Ê∏≤ÊüìÊúçÂä°Âô®Áä∂ÊÄÅ
  const renderServerStatus = (server: ServerConfig) => {
    const status = serverStatus[server.name];
    const statusConfig = {
      online: { color: "success" as const, text: "Âú®Á∫ø" },
      offline: { color: "error" as const, text: "Á¶ªÁ∫ø" },
      checking: { color: "processing" as const, text: "Ê£ÄÊü•‰∏≠" },
    };

    const config = statusConfig[status] || statusConfig.offline;

    return (
      <Badge
        status={config.color}
        text={
          <Text style={{ color: server.color, fontWeight: 500 }}>
            {config.text}
          </Text>
        }
      />
    );
  };

  // Ê∏≤Êüì‰∏ä‰º†ËÆ∞ÂΩï
  const renderUploadRecord = (record: UploadRecord) => {
    const server = servers.find((s) => s.name === record.serverName);
    if (!server) return null;

    const statusIcon = {
      pending: <LoadingOutlined style={{ color: "#faad14" }} />,
      uploading: <LoadingOutlined style={{ color: "#1890ff" }} />,
      success: <CheckCircleOutlined style={{ color: "#52c41a" }} />,
      error: <ExclamationCircleOutlined style={{ color: "#ff4d4f" }} />,
    };

    const statusColor = {
      pending: "warning",
      uploading: "processing",
      success: "success",
      error: "error",
    };

    return (
      <List.Item
        key={record.id}
        actions={[
          record.status === "error" && (
            <Button
              key="retry"
              size="small"
              icon={<PlayCircleOutlined />}
              onClick={() => handleUploadToServer(server)}
            >
              ÈáçËØï
            </Button>
          ),
        ].filter(Boolean)}
      >
        <List.Item.Meta
          avatar={
            <div style={{ color: server.color, fontSize: 24 }}>
              {server.icon}
            </div>
          }
          title={
            <Space>
              <Text strong>{record.fileName}</Text>
              <Tag color={statusColor[record.status]}>
                {record.status === "pending" && "Á≠âÂæÖ‰∏≠"}
                {record.status === "uploading" && "‰∏ä‰º†‰∏≠"}
                {record.status === "success" && "ÊàêÂäü"}
                {record.status === "error" && "Â§±Ë¥•"}
              </Tag>
              <Text type="secondary">‚Üí {record.serverName}</Text>
            </Space>
          }
          description={
            <div>
              <Space>
                <Text type="secondary">{formatFileSize(record.fileSize)}</Text>
                {record.speed > 0 && (
                  <Text type="secondary">
                    ÈÄüÂ∫¶: {formatFileSize(record.speed)}/s
                  </Text>
                )}
                {record.elapsedTime > 0 && (
                  <Text type="secondary">
                    Áî®Êó∂: {(record.elapsedTime / 1000).toFixed(2)}s
                  </Text>
                )}
              </Space>
              {record.status === "uploading" && (
                <Progress
                  percent={record.progress}
                  size="small"
                  status="active"
                  style={{ marginTop: 8 }}
                />
              )}
              {record.error && (
                <Text type="danger" style={{ display: "block", marginTop: 4 }}>
                  ÈîôËØØ: {record.error}
                </Text>
              )}
            </div>
          }
        />
      </List.Item>
    );
  };

  return (
    <div style={{ padding: "24px", background: "#f5f5f5", minHeight: "100vh" }}>
      <div style={{ maxWidth: 1200, margin: "0 auto" }}>
        <div style={{ textAlign: "center", marginBottom: 32 }}>
          <Title level={2} style={{ color: "#1890ff", marginBottom: 8 }}>
            üöÄ Âü∫‰∫é Uppy ÊúÄ‰Ω≥ÂÆûË∑µÁöÑ‰∏âÊúçÂä°Âô®‰∏ä‰º†ÊµãËØï
          </Title>
          <Paragraph type="secondary" style={{ fontSize: 16 }}>
            ÊµãËØï Node.js„ÄÅPython„ÄÅJava ‰∏âÁßçÂêéÁ´ØÁöÑÂ§ßÊñá‰ª∂ÂàÜÁâá‰∏ä‰º†ÊÄßËÉΩ
          </Paragraph>

          {/* Á°¨‰ª∂‰ø°ÊÅØÂ±ïÁ§∫ */}
          <Card
            size="small"
            style={{
              maxWidth: 600,
              margin: "16px auto",
              background: "#f0f9ff",
              border: "1px solid #1890ff",
            }}
          >
            <Space size="large">
              <Statistic
                title="üñ•Ô∏è CPU Ê†∏ÂøÉ"
                value={hardwareInfo.cores}
                suffix="Ê†∏"
                valueStyle={{ color: "#1890ff" }}
              />
              <Statistic
                title="üîÑ ÊúÄ‰ºòÂπ∂Âèë"
                value={hardwareInfo.optimalConcurrency}
                suffix="‰∏™"
                valueStyle={{ color: "#52c41a" }}
              />
              <Statistic
                title="üì¶ ÂàÜÁâáÂ§ßÂ∞è"
                value={hardwareInfo.chunkSize}
                suffix="MB"
                valueStyle={{ color: "#fa8c16" }}
              />
            </Space>
          </Card>
        </div>

        {/* ÊúçÂä°Âô®Áä∂ÊÄÅ */}
        <Row gutter={[16, 16]} style={{ marginBottom: 24 }}>
          {servers.map((server) => (
            <Col xs={24} sm={8} key={server.name}>
              <Card
                hoverable
                style={{
                  borderColor: server.color,
                  borderWidth: 2,
                }}
                bodyStyle={{ padding: 16 }}
              >
                <div style={{ textAlign: "center" }}>
                  <div
                    style={{
                      fontSize: 32,
                      color: server.color,
                      marginBottom: 8,
                    }}
                  >
                    {server.icon}
                  </div>
                  <Title level={4} style={{ margin: 0, color: server.color }}>
                    {server.name}
                  </Title>
                  <Text type="secondary" style={{ fontSize: 12 }}>
                    {server.description}
                  </Text>
                  <div style={{ marginTop: 8 }}>
                    {renderServerStatus(server)}
                  </div>
                  <div style={{ marginTop: 12 }}>
                    <Button
                      type={
                        activeServer === server.name ? "default" : "primary"
                      }
                      size="small"
                      style={{
                        backgroundColor:
                          activeServer === server.name
                            ? "#f0f0f0"
                            : server.color,
                        borderColor:
                          activeServer === server.name
                            ? "#d9d9d9"
                            : server.color,
                        color:
                          activeServer === server.name ? "#595959" : "#fff",
                      }}
                      disabled={
                        !selectedFile ||
                        serverStatus[server.name] !== "online" ||
                        (activeUploads.size > 0 && activeServer !== server.name)
                      }
                      loading={activeServer === server.name}
                      onClick={() => handleUploadToServer(server)}
                    >
                      {activeServer === server.name
                        ? "‰∏ä‰º†‰∏≠..."
                        : "‰∏ä‰º†Âà∞Ê≠§ÊúçÂä°Âô®"}
                    </Button>
                  </div>
                </div>
              </Card>
            </Col>
          ))}
        </Row>

        {/* Êñá‰ª∂ÈÄâÊã©Âå∫Âüü */}
        <Card title="ÈÄâÊã©ÊµãËØïÊñá‰ª∂" style={{ marginBottom: 24 }}>
          <Dragger
            name="file"
            multiple={false}
            beforeUpload={handleFileSelect}
            showUploadList={false}
            style={{ marginBottom: 16 }}
          >
            <p className="ant-upload-drag-icon">
              <InboxOutlined />
            </p>
            <p className="ant-upload-text">ÁÇπÂáªÊàñÊãñÊãΩÊñá‰ª∂Âà∞Ê≠§Âå∫Âüü</p>
            <p className="ant-upload-hint">
              ÊîØÊåÅÂ§ßÊñá‰ª∂‰∏ä‰º†ÔºåÂª∫ËÆÆ‰ΩøÁî®ËæÉÂ§ßÊñá‰ª∂ÊµãËØïÊÄßËÉΩÂ∑ÆÂºÇ
            </p>
          </Dragger>

          {selectedFile && (
            <Alert
              message={`Â∑≤ÈÄâÊã©Êñá‰ª∂: ${selectedFile.name}`}
              description={`Êñá‰ª∂Â§ßÂ∞è: ${formatFileSize(selectedFile.size)}`}
              type="info"
              showIcon
              style={{ marginBottom: 16 }}
            />
          )}

          <Row gutter={16} align="middle">
            <Col flex="auto">
              <Space size="large" wrap>
                <div>
                  <Text style={{ marginRight: 8 }}>üì¶ ÂàÜÁâáÂ§ßÂ∞è:</Text>
                  <Select
                    value={chunkSize}
                    onChange={(value) => setChunkSize(value)}
                    style={{ width: 120 }}
                    options={[
                      { value: 0.5, label: "0.5MB" },
                      { value: 0.8, label: "0.8MB ‚≠ê" }, // Êé®Ëçê
                      { value: 1, label: "1MB" },
                      { value: 2, label: "2MB" },
                      { value: 4, label: "4MB" },
                      { value: 8, label: "8MB" },
                      { value: 10, label: "10MB" },
                    ]}
                  />
                  <Text
                    type="secondary"
                    style={{ marginLeft: 8, fontSize: 12 }}
                  >
                    (Uppy Êé®Ëçê 0.8MB)
                  </Text>
                </div>

                <div>
                  <Text type="secondary">
                    üîÑ ÂΩìÂâçÂπ∂Âèë: {hardwareInfo.optimalConcurrency}‰∏™ | üìä
                    ÊÄªÂàÜÁâá:{" "}
                    {selectedFile
                      ? Math.ceil(selectedFile.size / (chunkSize * 1024 * 1024))
                      : 0}
                    ‰∏™
                  </Text>
                </div>
              </Space>
            </Col>

            <Col>
              <Space style={{ float: "right" }}>
                <Button
                  onClick={checkAllServers}
                  disabled={activeUploads.size > 0}
                  icon={<ReloadOutlined />}
                >
                  Âà∑Êñ∞Áä∂ÊÄÅ
                </Button>
                <Button
                  type="primary"
                  size="large"
                  icon={<CloudServerOutlined />}
                  disabled={!selectedFile || activeUploads.size > 0}
                  onClick={handleUploadToAll}
                >
                  ÊâπÈáè‰∏ä‰º†ÊµãËØï
                </Button>
              </Space>
            </Col>
          </Row>
        </Card>

        {/* ‰∏ä‰º†ËÆ∞ÂΩï */}
        <Card
          title="‰∏ä‰º†ËÆ∞ÂΩï"
          extra={
            <Button
              danger
              size="small"
              icon={<DeleteOutlined />}
              onClick={clearRecords}
              disabled={activeUploads.size > 0}
            >
              Ê∏ÖÁ©∫ËÆ∞ÂΩï
            </Button>
          }
        >
          {uploadRecords.length === 0 ? (
            <div style={{ textAlign: "center", padding: 40 }}>
              <Text type="secondary">ÊöÇÊó†‰∏ä‰º†ËÆ∞ÂΩï</Text>
            </div>
          ) : (
            <List
              dataSource={uploadRecords}
              renderItem={renderUploadRecord}
              style={{ maxHeight: 400, overflowY: "auto" }}
            />
          )}
        </Card>

        {/* ÊÄßËÉΩÁªüËÆ° */}
        {uploadRecords.length > 0 && (
          <Card title="ÊÄßËÉΩÂØπÊØî" style={{ marginTop: 24 }}>
            <Row gutter={16}>
              {servers.map((server) => {
                const serverRecords = uploadRecords.filter(
                  (record) =>
                    record.serverName === server.name &&
                    record.status === "success"
                );

                if (serverRecords.length === 0) return null;

                const avgSpeed =
                  serverRecords.reduce((sum, record) => sum + record.speed, 0) /
                  serverRecords.length;

                const avgTime =
                  serverRecords.reduce(
                    (sum, record) => sum + record.elapsedTime,
                    0
                  ) / serverRecords.length;

                return (
                  <Col xs={24} sm={8} key={server.name}>
                    <Card size="small" style={{ borderColor: server.color }}>
                      <Statistic
                        title={
                          <Space>
                            <span style={{ color: server.color }}>
                              {server.icon}
                            </span>
                            {server.name}
                          </Space>
                        }
                        value={formatFileSize(avgSpeed)}
                        suffix="/s"
                        valueStyle={{ color: server.color }}
                      />
                      <div style={{ marginTop: 8 }}>
                        <Text type="secondary">
                          Âπ≥ÂùáÁî®Êó∂: {(avgTime / 1000).toFixed(2)}s
                        </Text>
                      </div>
                      <div>
                        <Text type="secondary">
                          ÊàêÂäüÊ¨°Êï∞: {serverRecords.length}
                        </Text>
                      </div>
                    </Card>
                  </Col>
                );
              })}
            </Row>
          </Card>
        )}
      </div>
    </div>
  );
};
